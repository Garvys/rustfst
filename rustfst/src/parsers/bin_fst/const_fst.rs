use std::fs::{read, File};
use std::io::BufWriter;
use std::path::Path;

use failure::{Fallible, ResultExt};
use nom::bytes::complete::take;
use nom::multi::count;
use nom::number::complete::{le_f32, le_i32};
use nom::IResult;

use crate::fst_impls::const_fst::ConstState;
use crate::fst_impls::ConstFst;
use crate::fst_traits::{BinaryDeserializer, BinarySerializer, ExpandedFst};
use crate::parsers::bin_fst::fst_header::{FstHeader, OpenFstString, FST_MAGIC_NUMBER};
use crate::parsers::bin_fst::utils_parsing::{
    parse_final_weight, parse_fst_arc, parse_start_state,
};
use crate::parsers::bin_fst::utils_serialization::{write_bin_f32, write_bin_i32};
use crate::semirings::Semiring;

static CONST_MIN_FILE_VERSION: i32 = 1;
static CONST_ALIGNED_FILE_VERSION: i32 = 1;
static CONST_FILE_VERSION: i32 = 2;
static CONST_ARCH_ALIGNMENT: usize = 16;

fn parse_const_state<W: Semiring<Type = f32>>(i: &[u8]) -> IResult<&[u8], ConstState<W>> {
    let (i, final_weight) = le_f32(i)?;
    let (i, pos) = le_i32(i)?;
    let (i, narcs) = le_i32(i)?;
    let (i, niepsilons) = le_i32(i)?;
    let (i, noepsilons) = le_i32(i)?;

    Ok((
        i,
        ConstState {
            final_weight: parse_final_weight(final_weight),
            pos: pos as usize,
            narcs: narcs as usize,
            niepsilons: niepsilons as usize,
            noepsilons: noepsilons as usize,
        },
    ))
}

fn parse_const_fst<W: Semiring<Type = f32>>(i: &[u8]) -> IResult<&[u8], ConstFst<W>> {
    let stream_len = i.len();

    let (mut i, hdr) = FstHeader::parse(i, CONST_MIN_FILE_VERSION)?;
    let aligned = hdr.version == CONST_ALIGNED_FILE_VERSION;
    let pos = stream_len - i.len();

    // Align input
    if aligned && hdr.num_states > 0 {
        if pos % CONST_ARCH_ALIGNMENT > 0 {
            i = take(CONST_ARCH_ALIGNMENT - (pos % CONST_ARCH_ALIGNMENT))(i)?.0;
        }
    }
    let (mut i, const_states) = count(parse_const_state, hdr.num_states as usize)(i)?;
    let pos = stream_len - i.len();

    // Align input
    if aligned && hdr.num_arcs > 0 {
        if pos % CONST_ARCH_ALIGNMENT > 0 {
            i = take(CONST_ARCH_ALIGNMENT - (pos % CONST_ARCH_ALIGNMENT))(i)?.0;
        }
    }
    let (i, const_arcs) = count(parse_fst_arc, hdr.num_arcs as usize)(i)?;

    Ok((
        i,
        ConstFst {
            start: parse_start_state(hdr.start),
            states: const_states,
            arcs: const_arcs,
            // FIXME: Parse serialized symts
            isymt: None,
            osymt: None,
        },
    ))
}

impl<W: Semiring<Type = f32> + 'static> BinaryDeserializer for ConstFst<W> {
    fn read<P: AsRef<Path>>(path_bin_fst: P) -> Fallible<Self> {
        let data = read(path_bin_fst.as_ref()).with_context(|_| {
            format!(
                "Can't open ConstFst binary file : {:?}",
                path_bin_fst.as_ref()
            )
        })?;

        let (_, parsed_fst) = parse_const_fst(&data)
            .map_err(|_| format_err!("Error while parsing binary ConstFst"))?;

        Ok(parsed_fst)
    }
}

impl<W: 'static + Semiring<Type = f32>> BinarySerializer for ConstFst<W> {
    fn write<P: AsRef<Path>>(&self, path_bin_fst: P) -> Fallible<()> {
        let mut file = BufWriter::new(File::create(path_bin_fst)?);

        let hdr = FstHeader {
            magic_number: FST_MAGIC_NUMBER,
            fst_type: OpenFstString::new("const"),
            // TODO: This should be generated by the weight type
            arc_type: OpenFstString::new("standard"),
            version: CONST_FILE_VERSION,
            // TODO: Flags are used to check whether or not a symboltable has to be loaded
            flags: 0i32,
            // TODO: Once the properties are stored, need to read them. kExpanded
            properties: 1u64,
            start: self.start.map(|v| v as i64).unwrap_or(-1),
            num_states: self.num_states() as i64,
            num_arcs: self.arcs.len() as i64,
        };
        hdr.write(&mut file)?;

        let zero = W::zero();
        for const_state in &self.states {
            let f_weight = const_state
                .final_weight
                .as_ref()
                .unwrap_or_else(|| &zero)
                .value();
            write_bin_f32(&mut file, *f_weight)?;
            write_bin_i32(&mut file, const_state.pos as i32)?;
            write_bin_i32(&mut file, const_state.narcs as i32)?;
            write_bin_i32(&mut file, const_state.niepsilons as i32)?;
            write_bin_i32(&mut file, const_state.noepsilons as i32)?;
        }

        for arc in &self.arcs {
            write_bin_i32(&mut file, arc.ilabel as i32)?;
            write_bin_i32(&mut file, arc.olabel as i32)?;
            let weight = arc.weight.value();
            write_bin_f32(&mut file, *weight)?;
            write_bin_i32(&mut file, arc.nextstate as i32)?;
        }

        Ok(())
    }
}
